## 时延

传输时延： $L/R$

传播时延：$D/V$

时延带宽积：$D/V*R$

L: 数据长度、R：带宽、D：链路长度、V：信号传播速度

## 分组长度与误码率

**分组长度与延迟时间**

- 基于**排队论**，相同长度的分组在交换过程中延迟时间较小
- 其他条件相同，分组**长度**越长延迟**时间**越长。实时交互式通信适合分组长度小， 文件传输等非实时通信，长度可以适当增加。
- 分组太小，有效数据传输效率会降低， 需要在**延迟时间**与**开销**之间进行平衡

**分组长度与误码率**

- 分组长度 $L=x+h$,  x：数据长度， h：分组头长度
- $P_e$为信道误码率， 分组传输正确概率为：$P_s=（1-P_e）^{x+h}$     $P_s=（1-P_e）^L$
- 重发概率为 $1-P_s$
- 最佳分组长度为 $L_{opt}=\sqrt{\frac{h}{P_e}}$
- 最高信道利用率为 $\eta_{max}=(1-\sqrt{hP_e})^2$
- 分组长度建议在16B到4096B之间的$2^n$B为标准分组长度



## HTTP

1. 请求一个资源需要2RTT时间（TCP连接+传输报文）

> 设某网页的URL为“http://www.abe.com/index.html”，且该URL对应的IP地址在你的计算机上没有缓存；文件index.html引用了8个小图像。
> 在域名解析的过程中，无等待的一次DNS解析请求与响应时间记为RTTd，
> HTTP请求传输Web对象过程的一次往返时间记为RTTh。试给出：
> （1）该URL中的域名； www.abe.com
> （2)浏览器解析到该URL对应的IP地址的最短时间和最长时间； 
> 	查询本地DNS最短， RTTd
> 	主机->LocalDNS->RootDns->顶级DSN：com->权威DNS abe.com 4RTTd
> （3)若浏览器没有配置并行TCP连接，则基于HTTP1.0获取该Web页的完整内容（包括引用的图像)所需要的时间（不包括域名解析时间)；
> 	请求一个资源需要2RTTh, 共9个资源; 需要18RTTh
> （4)若浏览器配置5个并行TCP连接，则基于HTTP1.0获取该Web页的完整内容（包括引用的图像）需要的时间（不包括域名解析时间)；
> 	每次5个并行TCP连接，一共有8个小图像，第一次传输5个，第二次传输剩余的3个，所以为2轮。
> 	每轮都要打开一次TCP连接用了1个RTTh，又同时传输图像用了一个RTTh，所以为2轮*2个RTTh=4RTTh，
> 	加上最初的2个用于开TCP连接和获取Html文件的RTTh，共计2+4=6RTTh
> （5）若浏览器没有配置并行TCP连接，则基于非流水方式的HTTP1.1获取该Web页完整内容需要的时间
>  	1RTTh（TCP持久连接）+ 1RTTh（1次html内容获取）+  8RTTh（8个图像传输时间） = 10RTTh。
>
> （6）基于流水方式的HTTP1.1获取该Web页的完整内容（包括引用的图像)需要的时间（不包括域名解析时间)。
>  	1RTTh（TCP持久连接）+ 1RTTh （1次html内容获取）+ 1RTTh（8个图像传输时间）= 3RTTh。

## 停等协议的性能

停等协议的**信道利用率**为：发送数据的时间/(往返时间+发送数据的时间)
$$
\begin{align}
U_{sneder}  & = \frac{传输时延}{往返时间+发送数据的时间} \\
& = \frac{t_{Seg}}{t_{Seg}+RTT}  \\
& = \frac{L/R}{RTT+L/R}
\end{align}
$$

---

**示例**：1Gbps 的网络， 15ms端到端传播延迟(RTT=15*2=30ms)， 1kb分组

L=1KB = 1024*8bit=8kbit

R=1Gbps = $10^9$b/s



传输时延：
$$
\begin{align*}
T_{transmit} & =\frac{L \text{(Packet length in bits)}}{R\text{ (transmission rate, bps)}} \\
& =\frac{8kb/pkt}{10^9/sec}\\
& =0.000008192s\\
& =8 微秒 \\

U_{sender} &= \frac{L/R}{RTT+L/R} \\
&=\frac{0.008}{3\add+0.008} \\
&=0.00027

\end{align*}
$$
![image-20220629205001687](../imgs/image-20220629205001687.png)



在1Gbps链路上每30毫秒才发送一个分组（1KB），1秒才发送33KB数据





## 滑动窗口协议信道利用率

假设报文段的序号采用k位二进制串进行编号，则其编号空间为：$0 \backsim 2^k-1$ 共$2^k$个编号。

滑动窗口协议的窗口大小与序列号空间需要满足以下约束：

1. $W_s + W_r \leq 2^k$

2. 特殊情况下， 对于GBN协议 $W_r=1$, 则 $W_s\leq2^k-1$

3. 对于典型的$W_s=W_r=W$的SR协议，有：$W_s \leq 2^{k-1}$, 发送方与接收方窗口的大小一致，各占一半

4. 停等协议，GBN，SR协议信道利用率可以统一表示为 $t_{seg} = L/R$
   $$
   U_{sender}=\frac{W_s\times{t_{Seg}}}{t_{Seg}+RTT+t_{ACK}}
   $$
   $W_s=1$ 就是停等协议

   对于滑动窗口协议，信道利用率与发送窗口的大小有关，$W_s$足够大时，可以使$W_s\times{t_{Seg}}$大于$t_{Seg}+RTT+t_{ACK}$成立， 此时利用率为100%



## IP数据报分片

> 假设IP数据报总长度为$L$字节， MTU为$M$字节， 且 $L>M \;\&\; DF=0$ 是路由器可以进行分片
>
> 每分片最大可封装的数据长度(字节) 
> $$
> d = \lfloor{\frac{M-20}{8}}\rfloor\times{8}
> $$
> 分片总数
> $$
> n=\lceil\frac{L-20}{d}\rceil
> $$
> 每分片片偏移量字段值
> $$
> F_i=\frac{d}{8}(i-1)\;,\; 1\leq{i}\leq{n}
> $$
> 每个分片的总长度字段值
> $$
> L_i=\begin{cases}  d+20\;,\; 1\leq{i}<n \\
> L-d\times{(i-1)}\;,\; i=n
> \end{cases}
> $$
> 每个分片MF值
> $$
> MF_i=\begin{cases} 1 \;,\; 1\leq{i}<n\\
> 0\;,\; i=n
> \end{cases}
> $$



## 连续信道容量

> 根据奈奎斯特第一准则，对于理想无噪声的基带传输系统，最大频带利用率为 2Baud/Hz;
>
> 如果传输M进制基带信号，则理想`无噪声`信道的信道容量为：
> $$
> C=2B\log_{2}M
> $$
>
> 香浓公式给出了`有噪声`连续信道的信道容量公式:
> $$
> C=B\log_2(1+\frac{S}{N})
> $$
> B: 信道的带宽、S: 输入信号的功率、N: 信道加性高斯白噪声
>
> S/N: 信噪比
>
> 信噪比转换关系：
> $$
> (\frac{S}{N})_{dB}=10\log_{10}(\frac{S}{N})_{功率}
> $$



示例

已知某信道容量为8kHz; 信噪比为30dB； 求该信道的信道容量C

1. 先转换信噪比
2. 在利用公式计算容量

> 信噪比$\frac{S}{N}_{功率}=10\log_{10}(\frac{S}{N})=10^{\frac{\frac{S}{N}}{10}}=10^{30/10}=1000$
>
> $C=B\log_2(1+\frac{S}{N})=8*10^3\log_2(1+1000)\approx 80kbit/s$















时延带宽积

> 设信号传播速度为250000km/s; 分组长度L=512bit; 链路带宽R=100Mbit/s, 则使时延带宽积刚好为一个分组长度的链路长度D多少？
>
> 时延带宽积=传播时延*带宽；即 $G=\frac{D}{V}\times R$
>
> $512=\frac{D}{250000} \times 100000$
>
> $D=512V/100000$
>
> D=1280m

对于10Mbps的基带CSMA/CD网，MAC帧的最短帧长为64字节



> 设A、B两站之间相距2km，链路使用CSMA/CD协议进行通信。信号在网络上的传播速率为200000km/s，两站的发送速率为1Gbps，A首先发送数据，如果发生碰撞，试计算：
>
> (1)A站至多经过多长时间才能够检测到发生了碰撞?
>
> 最先发送数据的A站最晚经过2个传播时延才能检测到发生碰撞， 即 2*（2Km/200000Km/s）=20us
>
> (2)假设A要发送的帧足够长，检测到碰撞后，A已经发送了多少位数据?(要求写出计算过程）
>
> 20us可以发送数据 1Gbps*20us=20000bit

