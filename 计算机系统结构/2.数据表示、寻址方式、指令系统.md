# 寻址方式

**寻址方式**指的是指令按什么方式寻找（或访问）到所需的操作数或信息的。

寻址方式在多样性、灵活性、寻址范围、地址映像算法和地址变换速度等方面都有了很大的进展。



多数计算机都将主存、寄存器、堆栈分类编址， 分别有面向主存、面向寄存器、面向堆栈的寻址方式。

```mermaid
flowchart TD
a[面向主存]
b[面向寄存器]
c[面向堆栈]
d[寻址方式]
d--> a
d--> b
d--> c
```



- `面向主存`的寻址主要访问主存，少量访问寄存器

- `面向寄存器`的寻址主要访问寄存器，少量访问主存和堆栈

- `面向堆栈`的寻址主要访问堆栈，少量访问主存和寄存器



由指令中给出的逻辑地址如何形成操作数真地址有很多方式， 如立即、直接、间接、相对、变址等寻址方式。



## 寻址方式在指令中的指明方式

1. 占用操作码中的某些位来指明
2. 不占用操作码，在地址码部分专门设置寻址方式位字段指明



## 程序在主存中的定位技术

**逻辑地址与物理地址**

逻辑地址是程序员编程用的地址， 主存物理地址是程序在主存中的实际地址。



### 静态再定位

在目的程序装入主存时，有装入程序用软件方法把目的程序的逻辑地址变换为物理地址。

程序执行时，物理地址不再改变，称为静态再定位。

不利于故障定位和程序调试， 给重叠流水技术的采用造成困难。

### 动态再定位

基址寻址法

增加相应的`基址寄存器`和`地址加法器`硬件，在程序不做变换直接装入主存的同时，将装入主存的`起始地址`a`存入对应该道程序使用的基址寄存器`中。

程序执行时只要通过地址加法器将`逻辑地址`加上基址寄存器的`程序基址`形成物理（有效）地址后再访存即可。

把在执行每条指令时才形成访存物理地址的方法称为动态在定位。



基址寻址与变址寻址原理上相似，但不是同一概念

- 变址寻址是对诸如向量、数组等数据块运算的支持，以便于实现程序的循环
- 基址寻址是对逻辑地址空间到物理地址空间变换的支持，以利于实现程序的动态再定位



### 虚实地址映射表

地址加界法要求程序员所有变址空间不能超出实际主存的容量；采用虚拟存储器增加了映像表硬件后，是程序空间可以超出实际主存空间，进一步发展了动态在定位。



## 物理主存中信息的存储分布

信息有字节（8位），半字，单字，双字等不同宽度。 

为了使任何时候所需的信息都只用一个存储周期访问到，要求信息在主存中存放的地址必须是该信息宽度（字节数）的整数倍。否则存在信息跨主存边界存放。

信息在存储器中按整数边界存储对于保证访问速度是很有必要的， 但是会造成存储空间浪费。



# 指令系统的设计和优化

## 指令系统设计的基本原则

指令系统是程序设计者看计算机的主要属性， 是软、硬件的主要界面，它在很大程度上决定了计算机具有的基本功能



指令系统的设计包括指令的功能和指令格式设计。

功能：操作类型、寻址方式和具体操作内容



指令类型一般分为`非特权型`和`特权型`；

- 非特权型指令：
  - 主要给应用程序员使用，也可以供系统程序员使用。
  - 包括算数逻辑运算、数据传送、浮点运算、字符串、十进制运算、控制转移及系统控制等子类

- 特权型指令：
  - 只供系统程序员使用，用户无权使用。
  - 用户只有先经访管指令调用操作系统，再由操作系统来使用这些特权指令。
  - 包含启动I/O（多用户环境下）、停机等待、存储管理保护、控制系统状态、诊断等子类



指令系统设计的基本步骤（反复多次进行）

1. 根据应用初拟指令的分类和具体的指令
2. 试编出用该指令系统设计的各种高级语言的编译程序
3. 对各种算法编写大量的测试程序并进行模拟测试，看指令系统的操作码和寻址方式效能是否都比较高
4. 将程序中高频出现的指令串复合改成一条强功能新指令（硬件实现）；将频度很低的指令的操作改成用基本的指令组成的指令串来完成（软件实现）



编译程度设计者对指令系统的要求：

1. 规整性
2. 对称性
3. 独立性和全能性
4. 正交性
5. 可组合性
6. 可扩充性



系统接结构设计者对执行系统的期望：

1. 指令码密度适中
2. 兼容性
3. 适应性





## 指令操作码的优化

指令是由`操作码`和`地址码`两部组成的。

![](../imgs/2.3_1.drawio.png)



**指令格式优化**

指如何用最短的位数来表示指令的操作信息和地址信息，使程序中指令的平均字长最短。

操作码的优化上要用到哈夫曼压缩概念。



**哈夫曼研所概念基本思想**

当各种事件发生的概率不均等时，采用优化技术，对发生概率最高的事件用最短的位数（时间）来表示（处理）；

对出现概率较低的事件允许用较长的位数（时间）来表示（处理），就会使表示（处理）的平均位数（时间）缩短。



研究操作码的优化是为了`缩短指令字长`，减少程序总位数及增加指令字能表示的操作信息和地址信息。要对操作码进行优化，就要知道每种指令在程序中出现的概率（使用频度），一般可以通过对大量已有的典型程序进行统计求得。



例：

操作码采用定长码时，需要$\lceil log_2n \rceil$位表示$ｎ$条指令.

操作码的信息源熵 $H=-\sum_{i=1}^{n}P_i \log_2P_i, \;\;\; P:频度$



信息冗余 = $\frac{实际平均码长-H}{实际平均码长}$



平均码长=$\sum_{i=1}^{n}P_il_i$



15/15/15 编码法

8/64/512 编码法



指令的操作码优化编码方法有：哈夫曼编码，扩展操作码编码

## 指令字格式优化

只有操作码的优化，没有在地址码和寻址方式上采取措施，程序总位数还是难以减少.

为了不降低访存取指令的速度，就要维持`指令字按整数边界存储`。

操作码优化表示后的长度$l_i$会因$p_i$的不同而有多种，但操作码优化带来的$l_i$缩短，只使指令字出现空白浪费。



**多地址制**

实际应用中各种指令的操作数个数会有不同，因此可根据需要让指令系统采用多种地址制。同一种地址制还可以采用多种地址形式和长度，也可以用空白处来存放直接操作数或常数等。

让最常用的操作码最短，其地址码个数越多，就越能使指令字的功能增强，越可以从宏观上减少所需的指令条数。

![](../imgs/2.3_2.png)



**措施**

1. 采用扩展操作码，并根据指令的频度$p_i$的分布状况选择合适的编码方式，以`缩短操作码的平均长度`
2. 采用诸如基址，变址，相对，寄存器，寄存器间接，段式存放，隐式指明等多种寻址方式，以`缩短地址码的长度`，并在有限的地址长度内提供更多的地址信息
3. 采用0、1、2、3等多种地址制，以增强指令的功能，从宏观上缩短程序长度，并加快执行的执行速度
4. 在同种地址制内再采用多种地址形式，如寄存器-寄存器，寄存器-主存，主存-主存等； 让每种地址字段可以有多种长度，且让长操作码和短地址码进行组配。
5. 在维持指令字在存储器中按整数边界存储的前提下，使用多种不同指令字长度。



## 指令系统的发展和改进

**两种途径和方向**

为使计算机系统有更强的功能，更高的性能，更好的性能价格比，满足应用的需求，在指令系统的设计、发展和改进上有两种不同的途径：

1. 复杂指令系统计算机CISC
   1. 如何进一步增强原有指令的功能以及设置更为复杂的新指令以取代原先由软件子程序完成的功能；实现软件功能的硬化；
   2. 按此方向发展， 机器指令系统日渐庞大和复杂
   3. 可以从面向目标程序、面向高级语言、面向操作系统三个方面的优化实现来考虑
2. 精减指令系统计算机RISC
   1. 如何通过减少指令种数和简化指令功能来降低硬件设计的复杂度，提高指令的执行速度



### 按CISC 方向发展和改进指令系统

#### 面向目标程序的优化实现改进

**途径1** 通过对大量已有机器的机器语言程序及执行情况，统计各种指令和指令串的使用频度加以分析和改进

静态使用频度：着眼于减少目标程序所占用的存储空间

动态使用频度：着眼于减少目标程序的执行时间

**途径2** 增设强功能复合指令来取代原先由常用宏指令或子程序实现的功能，由微程序解释实现，不仅大大提供运算速度，减少了程序调用的开销，还减少了子程序占用的主存空间。

#### 面向高级语言的优化实现改进

**途径1** `通过对源程序中各种高级与语言语句的使用频度进行统计来分析改进`

**途径2** 如何面向编译、优化代码生成来改进；`应当增强系统结构的规整性，尽量减少例外或特殊的情况和用法`，让所有运算都对称、均匀地在存储器（寄存器）单元间进行。对所有存储（寄存器）单元都同等对待，无论是操作数或运算结果都可以无约束地存放在任意单元中。这样为优化管理通用寄存器的使用可以大大减少辅助开销。

**途径3** 改进指令系统，使它与各种高级语言的语义差距都有同等的缩小

**途径4** 由”`指令系统为主，高级语言为从`“ 方式演变为以”`高级语言为主，指令系统为从`“的方式

**途径5** 发展高级语言计算机；基本特点是没有编译；

1. 让高级语言直接称为机器的汇编语言。间接执行的高级语言机器
2. 让高级语言本身成为机器语言，由硬件或固件逐条进行解释执行。直接执行的高级语言机器



#### 面向操作系统的优化实现改进

主要目标是如何通过缩短操作系统与计算机系统结构之间的语义差距，进一步减少操作系统的时间和节省操作系统所占用的存储空间。

**途径1** 对操作系统中常使用的指令和指令串进行`统计分析`来改进；效果有限

**途径2** 考虑如何`增设专用`于操作系统的`新指令`

**途径3** 把操作系统频繁使用的，对速度影响较大的机构型软件子程序`硬化或固化`，改为直接用硬件或微程序解释实现

**途径4** 发展让操作系统由专门的处理机来执行的功能`分布处理`系统结构



### 按RISC方向发展和改进指令系统

**CISC的问题**

1. 指令系统庞大， 一般在200条以上
2. 许多指令的操作繁杂，执行速度很低；
3. 由于指令系统庞大，使高级语言编译程序选择`目标指令的范围太大`，难以优化生成高效机器语言程序，编译程序也太长太复杂
4. 由于指令系统庞大，各种指令的使用频度都不会太高，且差别很大，其中相当一部分利用率很低



#### 设计RISC的基本原则

1. 确定指令系统时，只选择使用频度很高的那些指令；在增加少量能有效支持操作系统、高级语言实现及其他功能的指令；一般<100条
2. 减少指令系统所使用的寻址方式种类
3. 让所有指令都在一个机器周期内完成
4. 扩大通用寄存器数，一般不少于32，尽量减少访存；
5. 为提供指令执行速度，大多数指令采用硬联控制实现，少数指令才用微程序实现
6. 通过精简指令和优化设计编译程序，简单有效地支持高级语言实现



#### 基本技术

1. 按设计RISC的一般原则来设计
2. 逻辑实现采用硬联和微程序相结合
3. 在CPU中设置大量工作寄存器并采用重叠寄存器窗口
4. 指令用流水和延迟转移
5. 采用高速换从存储器Cache， 采用指令Cache和数据Cache分别存放指令和数据
6. 优化设计编译系统



































